


# 组件化

android组件化开发
https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=android%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91&oq=Android%2520%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596&rsv_pq=d889a1210000a5dd&rsv_t=838alQdqI9Qn9Vhxpe2VnIpA61cVDPp4%2F1RJdrQi2iGaybdmD2mDT1aulik&rqlang=cn&rsv_enter=1&rsv_sug3=2&rsv_sug1=2&rsv_sug7=100&rsv_sug2=1&prefixsug=Android%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596&rsp=0&inputT=2071&rsv_sug4=2809

android 组件化开发
https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=android%20%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91&oq=android%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsv_pq=eecb36e20000a77a&rsv_t=1732TLqhlZ1FVCDGHwMXn0def85CqeLmt73LlJtxYynAXuS1h70YmqbPKVg&rqlang=cn&rsv_enter=1&rsv_sug3=10&rsv_sug1=10&rsv_sug7=100&rsv_sug2=1&prefixsug=android%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsp=1&rsv_sug4=34457&rsv_sug=1

android组件化开发面试
https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=android%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95&oq=android%2520%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsv_pq=f8eadd0f0000a6ef&rsv_t=a1f9FF0D4ZWxJgWg0tUMvWiUlWOa%2B8e86WSQ6Dz%2BOdg9pyv7gGYOef4Ek1A&rqlang=cn&rsv_enter=1&rsv_sug3=16&rsv_sug1=16&rsv_sug7=100&rsv_sug2=1&prefixsug=android%25E7%25BB%2584%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsp=3&inputT=1489&rsv_sug4=25920&rsv_sug=1

# 插件化

android插件化
https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=android%E6%8F%92%E4%BB%B6%E5%8C%96&oq=android%25E6%258F%2592%25E4%25BB%25B6%25E5%258C%2596&rsv_pq=9b5fd4e500009d28&rsv_t=270bcboKXilpv4GtWpuNAnvWoydKymBp0xTb7CTeHYd97cEQciqeBUEB7dU&rqlang=cn&rsv_enter=0&rsv_sug3=35&rsv_sug1=35&rsv_sug7=100&prefixsug=android%25E6%258F%2592%25E4%25BB%25B6%25E5%258C%2596&rsp=3&rsv_sug4=19217&rsv_sug=1

android插件化原理
https://www.baidu.com/s?ie=utf-8&f=3&rsv_bp=1&tn=baidu&wd=android%E6%8F%92%E4%BB%B6%E5%8C%96%E5%8E%9F%E7%90%86&oq=android%25E6%258F%2592%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsv_pq=d9d90e8f0000a250&rsv_t=a8ddjTD78Izh45wandcvqe1LhpissCr863j6pnt%2FxeQo8RsFW9mXcGYxohc&rqlang=cn&rsv_enter=0&rsv_sug3=37&rsv_sug1=37&rsv_sug7=100&rsv_sug2=1&prefixsug=android%25E6%258F%2592%25E4%25BB%25B6%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsp=2&rsv_sug4=3408&rsv_sug=1

![](./pics/插件化.png)

#### 热修复

Tinker热修复原理
https://www.baidu.com/s?wd=Tinker%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86

andfix热修复原理
https://www.baidu.com/s?wd=andfix%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86

Android热修复原理
https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1&tn=baidu&wd=Android%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%8E%9F%E7%90%86&oq=Android%2520%25E7%2583%25AD%25E4%25BF%25AE%25E5%25A4%258D%25E5%258E%259F%25E7%2590%2586&rsv_pq=b6571627000035fc&rsv_t=dfb4n1HYTXWK7uYB0zTs4SrN%2BJ2A9Bg1ujOv4bzPjDVc0UqISlKr3NgT2Eg&rqlang=cn&rsv_enter=0&rsv_sug3=17&rsv_sug1=14&rsv_sug7=100&rsv_sug2=0&inputT=545&rsv_sug4=3211

微信：tinker

微信针对QQ空间超级补丁技术的不足提出了一个提供DEX差量包，整体替换DEX的方案。

主要的原理是与QQ空间超级补丁技术基本相同，区别在于不再将patch.dex增加到elements数组中，而是差量的方式给出patch.dex，

然后将patch.dex与应用的classes.dex合并，然后整体替换掉旧的DEX，达到修复的目的。

QQ：Qzone

支付宝：andfix ：方法的替换，把有bug的方法替换成补丁文件中的方法

美团：robust

手机淘宝：dexposed

关于Android热修复的几种解决方案
https://blog.csdn.net/wy12345432452/article/details/77482554

Android 热修复，没你想的那么难
https://kymjs.com/code/2016/05/08/01/


Android中有两个ClassLoader分别为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader。

1、DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk
2、PathClassLoader只能加载系统中已经安装过的apk


PathClassLoader 

它只能加载已经安装的apk。

因为 PathClassLoader 只会去读取 /data/dalvik-cache 目录下的 dex 文件。

例如我们安装一个包名为com.hujiang.xxx的 apk,那么当 apk 安装过程中，就会在/data/dalvik-cache目录下生产一个名为data@app@com.hujiang.xxx-1.apk@classes.dex的 ODEX 文件。

在使用 PathClassLoader 加载 apk 时，它就会去这个文件夹中找相应的 ODEX 文件，如果 apk 没有安装，自然会报ClassNotFoundException。

DexClassLoader 

是最理想的加载器。它的构造函数包含四个参数，分别为：

dexPath,指目标类所在的APK或jar文件的路径.类装载器将从该路径中寻找指定的目标类,该类必须是APK或jar的全路径.如果要包含多个路径,路径之间必须使用特定的分割符分隔,特定的分割符可以使用System.getProperty(“path.separtor”)获得.

dexOutputDir,由于dex文件被包含在APK或者Jar文件中,因此在装载目标类之前需要先从APK或Jar文件中解压出dex文件,该参数就是制定解压出的dex 文件存放的路径.在Android系统中,一个应用程序一般对应一个Linux用户id,应用程序仅对属于自己的数据目录路径有写的权限,因此,该参数可以使用该程序的数据路径.

libPath,指目标类中所使用的C/C++库存放的路径

classload,是指该装载器的父装载器,一般为当前执行类的装载器



热修复的原理

http://androidxref.com/4.0.4/xref/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java

http://androidxref.com/4.0.4/xref/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java

DexClassLoader 包含有一个dex数组Element[] dexElements，其中每个dex文件是一个Element，当需要加载类的时候会遍历 dexElements，如果找到类则加载，如果找不到从下一个 dex 文件继续查找。

那么我们的实现就是把这个插件 dex 插入到 Elements 的最前面，这么做的好处是不仅可以动态的加载一个类，并且由于 DexClassLoader 会优先加载靠前的类，所以我们同时实现了宿主 apk 的热修复功能。




为什么 Android 不能识别 .class 文件，而只能识别 dex 文件。

因为 dex 是对 class 的优化，它对 class 做了极大的压缩

dex 将整个 Android 工程中所有的 class 压缩到一个(或几个) dex 文件中，合并了每个 class 的常量、class 版本信息等，例如每个 class 中都有一个相同的字符串，在 dex 中就只存一份就够了。所以，在Android 上，dalvik 虚拟机是无法识别一个普通 class 文件的，因为无法识别这个 class 文件的结构。

其实 dalvik 虚拟机也并不是直接读取 dex 文件的，而是在一个 APK 安装的时候，会首先做一次优化，会生成一个 ODEX 文件，即 Optimized dex。 为什么还要优化，依旧是为了效率。

只不过，Class -> dex 是为了平台无关的优化；
而 dex -> odex 则是针对不同平台，不同手机的硬件配置做针对性的优化。

就是在这一过程中，虚拟机在启动优化的时候，会有一个选项就是 verify 选项，当 verify 选项被打开的时候，就会执行一次校验，校验的目的是为了判断，这个类是否有引用其他 dex 中的类，如果没有，那么这个类会被打上一个 CLASS_ISPREVERIFIED 的标志。一旦被打上这个标志，就无法再从其他 dex 中替换这个类了。而这个选项开启，则是由虚拟机控制的。


# 模块化

android 模块化
https://www.baidu.com/s?wd=android%20%E6%A8%A1%E5%9D%97%E5%8C%96&rsv_spt=1&rsv_iqid=0xd4471dfc00094c7d&issp=1&f=8&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&oq=%25E6%25A8%25A1%25E5%259D%2597%25E5%258C%2596&rsv_t=7d0fmt1FHDAjX8igGhDdp7a8QnBCEG7C6lSuJdxk9N%2F4uyhGGrJ3JnRVcY7ZGwXbG3G2&inputT=1777&rsv_sug3=20&rsv_sug1=14&rsv_sug7=100&rsv_pq=b6a7fef500075a0c&rsv_sug2=0&rsv_sug4=2233

android 模块化开发
https://www.baidu.com/s?wd=android%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91&rsv_spt=1&rsv_iqid=0xd4471dfc00094c7d&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&oq=android%2520%25E6%25A8%25A1%25E5%259D%2597%25E5%258C%2596&rsv_t=133boa%2BPkMpr5xonFEJH%2BAa1B0ZYVmubgchvLMOVtY%2FsdOstajCAaFec5yEo8eUUgn7U&rsv_pq=ea09f16d0006f3a8&rsv_sug3=24&rsv_sug1=18&rsv_sug7=100&rsv_sug2=1&prefixsug=android%2520%25E6%25A8%25A1%25E5%259D%2597%25E5%258C%2596&rsp=0&rsv_sug4=28127

android 模块化开发实例
https://www.baidu.com/s?wd=android%20%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E5%AE%9E%E4%BE%8B&rsv_spt=1&rsv_iqid=0xd4471dfc00094c7d&issp=1&f=3&rsv_bp=1&rsv_idx=2&ie=utf-8&rqlang=cn&tn=baiduhome_pg&rsv_enter=1&oq=android%2520%25E6%25A8%25A1%25E5%259D%2597%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsv_t=717eR2BIuSQH7T1GB557zBjNQTDOomVU2ak8IMy8Y6U9kDZyRPAGNRhFdF%2BK%2FM0rSEzv&rsv_pq=c9bf08cd000773d4&rsv_sug3=28&rsv_sug1=22&rsv_sug7=100&rsv_sug2=1&prefixsug=android%2520%25E6%25A8%25A1%25E5%259D%2597%25E5%258C%2596%25E5%25BC%2580%25E5%258F%2591&rsp=2&rsv_sug4=29262

> 【组件化Component】 ≈ 【模块化module】：Arouter
> 插件化：热更新

<font color="#ff0000">【组件Component】</font>
中文称为组件，或者构件。使用非常比较广泛，它的核心意义在于复用，相对模块，对于依赖性有更高的要求。 

<font color="#ff0000">【模块Module】</font>
中文为模块或模组。它的核心意义是分离职责，属于代码级模块化的产出。
它本身是提供服务的功能逻辑，是一组具有一定内聚性代码的组合，职责明确。 

组件(Component)和模块(Module)又是一对容易混淆的名词，也常常被用来相互替换。

从设计上来看，<font color="#ff0000">【组件强调复用，模块强调职责(内聚、分离)，或者说组件是达到可复用要求的模块】</font>

摘自：http://blog.sina.com.cn/s/blog_a703eb840102xp2g.html

【组件化】开发就是将一个app分成多个模块，每个模块都是一个组件（Module），
开发的过程中我们可以让这些组件相互依赖或者单独调试部分组件等，
但是最终发布的时候是将这些组件合并统一成一个apk，这就是组件化开发。 

【插件化】开发和组件化开发略有不用，插件化开发时将整个app拆分成很多模块，
这些模块包括一个宿主和多个插件，每个模块都是一个apk（组件化的每个模块是个lib），
最终打包的时候将宿主apk和插件apk分开或者联合打包。

摘自：https://blog.csdn.net/lijizhi19950123/article/details/77945153

通信方式

模块化的通信方式，无非是相互引入；我抽取了common, 其他模块使用自然要引入这个module
组件化的通信方式，按理说可以划分为多种，主流的是隐式和路由。隐式的存在使解耦与灵活大大降低，因此路由是主流
插件化的通信方式，不同插件本身就是不同的进程了。因此通信方式偏向于Binder机制类似的进程间通信

组件化的单位是组件（module）。
插件化的单位是apk(一个完整的应用)。

#### module与apk来分：

模块化、组件化（分包-->module）
模块化：框架
组件化：基础库和公共组件（网络封装等）

每个模块可以独立开发编译运行 
开发单个模块时可以共享资源和工具类 
可以针对单个模块测试 


android工程的组件一般分为两种，lib组件和application组件 
application组件是指该组件本身就可以运行并打包成apk 
lib组件是指该组件属于app的一部分，可以供其它组件使用但是本身不能打包成apk

[Android 组件化总结](https://blog.csdn.net/yuzhiqiang_1993/article/details/80664398)


插件化（apk）

热部署：热修复
动态加载资源：动态换肤
四大组件动态加载：模块化开发

宿主和插件分开编译 
并发开发 
动态更新插件 
按需下载模块 
解决方法数过多的问题





[Android apk动态加载机制的研究（二）：资源加载和activity生命周期管理
](https://blog.csdn.net/singwhatiwanna/article/details/23387079)


组件化开发：

> 就是将一个app分成多个Module，每个Module都是一个组件(也可以是一个基础库供组件依赖)，开发的过程中我们可以单独调试部分组件，组件间不需要互相依赖，但可以相互调用，最终发布的时候所有组件以lib的形式被主app工程依赖并打包成1个apk。

插件化开发：

> 和组件化开发略有不用，插件化开发时将整个app拆分成很多模块，这些模块包括一个宿主和多个插件，每个模块都是一个apk（组件化的每个模块是个lib），最终打包的时候将宿主apk和插件apk(或其他格式)分开或者联合打包。



#### 模块化的模块单独编译

[一篇文章搞懂 Android 组件化](https://mp.weixin.qq.com/s/PEIOXtrkK5qvxn1WggiKkg)

[Android彻底组件化方案实践](https://www.jianshu.com/p/1b1d77f58e84)

[吴小龙：Android 组件化探索与思考](https://mp.weixin.qq.com/s?__biz=MzI4MTQyNDg3Mg==&mid=2247484157&idx=1&sn=77d6be61a0858dae89fe6c33f4e36672&chksm=eba8247adcdfad6cf1217726adf297d11fa6725beb234e5d9a975d5c21f0b97b5588942c8454&mpshare=1&scene=24&srcid=0804zA1qZ9v85Gh8qyfIJXlR#rd)

在组件化项目中

除了有commonLib和app模块外，我们按照功能划分各个业务组件模块（eg:微信可以划分出chat，contract，find，mine四个大模块），

之前的包变成现在的模块，增加了层次感；每个功能模块可以单独编译，加快了编译速度，也为提供单元模块测试提供了支持；

多人开发只负责自己的模块，直接避免了版本管理的冲突。

初步实现组建化其实我们最终要解决的问题就只有2个：

> 1.设置模块之间的依赖，且使得业务模块可单独编译--通过配置gradle即可解决
> 2.业务模块之间的页面跳转以及通信--使用阿里开源的ARouter即可解决

config.gradle:
```
ext {
    isDouBanApplication = false  
	//豆瓣模块开关，false:作为Lib组件存在， true:作为application存在
}
```

module的build.gradle:

```
//控制组件模式和集成模式
if (rootProject.ext.isGankApplication) {
    apply plugin: 'com.android.application'
} else {
    apply plugin: 'com.android.library'
}


android {
    defaultConfig {
        if (rootProject.ext.isGankApplication){
            //组件模式下设置applicationId
            applicationId "com.ycbjie.gank"
        }
    }
}
```






















